## 函数式编程

1. 函数做返回值

> 函数可以作为返回值，当返回函数时，相关的参数和变量都会保留在返回的函数中，只有当计算时才会被确定。这种程序结构称为闭包(Closure)
> 闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。
> 在使用闭包结构时要注意，返回结果中不要含有任何循环变量或者后来会发生改变的变量。

```python
# 以下是一个不当使用闭包的例子
def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
```

```python
# 练习
def createCounter():
x = 0

def counter():
    nonlocal x  # 必须声明nonlocal否则不能成功
    x += 1
    return x

return counter
counterB = createCounter()
print(counterB(), counterB(), counterB(), counterB(), counterB())
```

2. 匿名函数

> 匿名函数是用来简化某些简单函数的使用

```python
# 改为匿名函数
# def is_odd(n):
#     return n % 2 == 1
L = list(filter(lambda x: x % 2 == 1, range(1, 20)))
print(L)

```

3. 装饰器

> 装饰器可以在不修改原函数定义的情况下改变，原函数的输出内容。
> 如果想要让装饰器带参数就要多加一层嵌套用来接受 func 参数，最外层函数接受新增加的参数

```python
# 不可以接受参数的装饰器
def docorator(func):
    def wrapper(*args, **kw):
        print("LonglongAgo...")
        return func(*args, **kw)

    return wrapper
# 可以接受参数的装饰器
def fine(text):
def docorator(func):
    def wrapper(*args):  # from func
        print(text)
        return func(*args)

    return wrapper

return docorator

# 在前后增加内容
import functools


def docorator(func):
    functools.wraps(func)

    def wrapper(*args, **kw):
        print("begin call")
        temp = func(*args, **kw)
        print("end call")
        return temp

    return wrapper
```

4. 偏函数

> 偏函数时 functiontools 提供的功能，他就像 bash 里的 alias 一样，用于简化复杂函数参数的设置

```python
import functools

printf = functools.partial(print, end="")
printf("Hello,")
printf("World!")

```
