## 错误调试和测试

1. 错误处理

> try...except...finally...当 try 语句中出现 except 中的异常，停止 try 语句执行 except 最后执行 finally 语句。
> 只需要在合适的位置使用 try-except-finally 语句就可以简化错误调试
> 抛出异常 raise，记录错误 logging
> 阅读异常信息

```python
from functools import reduce
def str2num(s):
    return int(s) #此处改为float()
def calc(exp):
    ss = exp.split("+")
    ns = map(str2num, ss)
    return reduce(lambda acc, x: acc + x, ns)
def main():
    r = calc("100 + 200 + 345")
    print("100 + 200 + 345 =", r)
    r = calc("99 + 88 + 7.6")
    print("99 + 88 + 7.6 =", r)
main()

Traceback (most recent call last):
  File "C:\Users\PC\Desktop\PyLXF\test\youbing.py", line 21, in <module>
#21出错是由于17
    main()
  File "C:\Users\PC\Desktop\PyLXF\test\youbing.py", line 17, in main
    r = calc("99 + 88 + 7.6")
        ^^^^^^^^^^^^^^^^^^^^^
#17出错是由于11
  File "C:\Users\PC\Desktop\PyLXF\test\youbing.py", line 11, in calc
    return reduce(lambda acc, x: acc + x, ns)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#11出错是由于5
  File "C:\Users\PC\Desktop\PyLXF\test\youbing.py", line 5, in str2num
    return int(s)
           ^^^^^^
#最终定位出错位置在5
ValueError: invalid literal for int() with base 10: ' 7.6'
```

2. 调试

> 调试程序的几种方式
> print,assert：print 和 assert 会使程序调试信息和内容混在一起，assert 唯一的好处是不需要删除只需要添加参数 -o 就可以关闭 assertion
> logging：的好处有可以设置输出日志的级别，还可以分别将内容输出到文件和命令行

```python
# logging
import logging
logging.basicConfig(level=debug)
string0 = "0"
int0 = int(string0)
logging.info(int0)
print(10 / int0)

```

> pdb，单步调试和设置断点
> logging 才是终极武器？

3. 单元测试

> 可以为一个模块或者一个函数编写单元测试，当需要修改时如果能保证修改前后单元测试均能通过则可以相对确定代码更新没有 BUG
> setup()tearDown()可以单元测试的每一类测试中先进行 setup 后进行 teardown 内容不需要重复编写。

```python
# 编写一个mydict，写一个unittest
from typing import Any
import unittest

class Mydict(dict):
    def __init__(self, **kws):
        super().__init__(**kws)

    def __setattr__(self, key: str, value: Any) -> None:
        self[key] = value

    def __getattr__(self, value) -> Any:
        try:
            return self[value]
        except KeyError:
            raise AttributeError

class testMydict(unittest.TestCase):
    def test_basicUse(self):
        md0 = Mydict(a=1, b=2)
        self.assertEqual(md0.a, md0["a"])

unittest.main()

```

4. 文档测试

> 再看代码库时经常看到在定义开头的特殊格式注释起来的示例代码，python 的模块 doctest 允许检查实例代码输入使出是否一致
> 更多的是一种说明作用，方便使用。

```python
# 在编写的Mydict基础上继续编写他的doctest
# doctest
class Mydict(dict):
    """
    Mydict is dict but also support access as x.y style.

    Example:

    >>> d1=Mydict()
    >>> d1["x"]=10
    >>> d1.x
    10
    """
    def __init__(self, **kws):
        super().__init__(**kws)

    def __setattr__(self, key: str, value: any) -> None:
        self[key] = value

    def __getattr__(self, value) -> any:
        try:
            return self[value]
        except KeyError:
            raise AttributeError

if __name__ == "__main__":
    import doctest

    doctest.testmod()
```
