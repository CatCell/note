## 高阶函数

1. map/reduce

> map(func, \*iterables) --> map object
> 将 func 一次作用于后面的\*iterables,可以很方便进行对序列求和，int 序列转换为整数等操作

```python
# 序列变为整数
def f(x,y):
return 10*x+y
reduce(f,[1,2,3,4])

# str2int
from functools import reduce


def str2int(s):
transTable = {"1": 1, "2": 2}

def strDig(str0):
    return transTable[str0]

def f(x, y):
    return 10 * x + y

return reduce(f, map(strDig, s))


print(str2int("1212"))

# str2float
from functools import reduce


def str2float(str0):
DOTpos = str0.index(".")

def charDig(Char0):
    dictT = {"1": 1, "2": 2, "3": 3}
    return dictT[Char0]

def fn(x, y):
    return 10 * x + y

def Num0dot(str0):
    return [i for i in str0 if i != "."]

return reduce(fn, map(charDig, Num0dot(str0))) * 10 ** -(len(str0) - DOTpos - 1)


str0 = "1212.1212"
print(str2float(str0))

```

2. filter

> filter(function or None, iterable) --> filter object
> 按照 func 过滤序列（列表推导式也可以起到过滤的效果，二者都对 iterable 对象可用）

```python
# 埃氏算法求素数
def OriNums():
n = 1
while True:
    n += 2
    yield n


def f(n):
return lambda x: x % n != 0


def Primes():
it = OriNums()
filter(f(2), it)
yield 2
while True:
    Prime0 = next(it)
    yield Prime0
    it = filter(f(Prime0), it)


times = 0
for i in Primes():
times += 1
if times > 10:
    break
print(i)
```

3. sorted

> sorted(iterable, /, \*, key=None, reverse=False)
> 将 iterable 按照 key 进行排序，很方便的选择进行排序和倒序

```python
# L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]
# 请用sorted()对上述列表分别按名字排序

# name
def by_name(tuple0):
    return tuple0[0]
# score
def by_score(tuple0):
    return tuple0[1]

L = [("Bob", 75), ("Adam", 92), ("Bart", 66), ("Lisa", 88)]
L2 = sorted(L, key=by_score)
L1 = sorted(L, key=by_name)

print(L1, L2)

```
