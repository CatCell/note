## 面向对象高级编程

1. slots

> 一般来说，实例可以自由拥有除类属性之外的属性。slots 用于限制实例的属性添加。
> 注意 slots 对继承子类是不起作用的。

```python
class student:
__slots__ = ("name", "ID")
```

2. @property

> @property 装饰器用实例属性的方式访问变量同时添加对参数的检查

```python
class screen:
    @property
    def wid(self):
        return self._wid

    @wid.setter
    def wid(self, value):
        self._wid = value

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        self._height = value

    @property
    def resolution(self):
        return self._height * self._wid

    # 如果按照设置属性的写法，是没有办法设置的因为resolution没有setter
```

3. 多重继承

> 设计类的时候通常是单一继承下来的，但有时需要在类中混入两个以上类的功能，可以使用 MinIN。(多数时候是不推荐的)

```python
class Dog(Object,Animal,canivore):
    pass
```

4. 定制类

> 以双下划线开头结尾的特殊名称的函数具有特殊功能
> \_\_str\_\_(),\_\_repr\_\_()
> 前者返回 print(instance1) 后者返回 instance1 的值
> \_\_iter\_\_(),\_\_next\_\_()
> 使得创建的实例 iterable

```python
# fibINiter
class Fib:
    def __init__(self) -> None:
        self.a = 0
        self.b = 1

    def __iter__(self):
        return self

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b
        return self.a


for i in Fib():
    if i > 1000:
        break
    print(i)

```

> \_\_getitem\_\_(),\_\_setitem\_\_(),\_\_delitem\_\_()
> 使得 iterable 可以使用切片，像列表，字典一样(duck typing)  
> \_\_getattr\_\_()
> 当引用不存在或者额外属性时生效
> \_\_call\_\_()
> 使得实例可以 call 自身

```python
class chain:
    def __init__(self, path="") -> None:
        self._path = path

    def __call__(self, name) -> Any:
        return chain(self._path + "/" + name)

    def __getattr__(self, __name: str) -> Any:  #
        return chain(self._path + "/" + __name)

    def __str__(self):
        return self._path


print(chain().users("MIchael").Location)
```

5. 使用枚举类

> 为常量定义一个类，每个常量都是这个类的唯一实例，这可以用@property 和 Enum 类来实现。

```python
# 将student的gender属性改造为枚举类型
from enum import Enum, unique


@unique
class gender(Enum):
    male = 0
    female = 1


class student:
    def __init__(self, name, gender) -> None:
        self._gender = gender
        self._name = name

    @property
    def gender(self):
        return self._gender

    @gender.setter
    def gender(self, value):
        self._gender = value


s0 = student("Tom", gender.male)
print(s0.
```

6. 使用元类

> 使用 type 函数定义类，和之前的写法效果相同
> metaclass 没怎么看懂，跳过了

```python
# typeDefine
def Fn(self):
    print("I am Method1")


Hello = type("Hello", (object,), dict(method1=Fn))  # dict
Hello0 = Hello()
Hello0.method1()

```
